Використання анонімних функцій в PYTHON.
Python підтримує концепцію анонімних функцій, яку також називають лямбда-функціями. Анонімна частина імені заснована на тому, що функції не потрібно мати імені. Частина лямбда заснована на використанні ключового слова lambda для їх визначення в Python. 
Але основна причина, що ім'я використовується в Python, полягає в тому, що термін лямбда використовується для опису анонімних функцій в обчисленні. 
Мінімальний синтаксис для визначення лямбда-виразу (без імені) з Python:
Аргументи Лямбди: вираз
Під час використання:
Замініть аргументи на дані, що передаються у вираз. Замініть вираз виразом (формулою), який визначає те, що потрібно повернути лямбда. 
Досить поширений приклад використання цього синтаксису - це коли ви намагаєтесь сортувати рядки тексту, де деякі імена починаються з великих літер, а деякі починаються з малих літер, як у цих назвах:
Адамс, Ма, діМеола, Зандуський
Припустимо, ви пишете наступний код, щоб помістити імена до списку, відсортувати його, а потім роздрукувати список, як це:
names = ['Adams', 'Ma', 'diMeola', 'Zandusky']
names.sort ()
друк (імена)
Результат цього:
['Адамс', 'Ма', 'Зандуський', 'diMeola']
Після того, як diMeola прийде після Зандуського, деякі початківці здаються неправильними. Але комп’ютери не завжди бачать речі так, як ми. Причина diMeola виникає після Зандуського в тому, що сортування засноване на ASCII, що є системою, в якій кожен символ представлений цифрою.
Усі малі літери мають цифри, що перевищують великі. Отже, при сортуванні всі слова, що починаються з малих літер, йдуть після слів, які починаються з великої літери. Якщо нічого іншого, це принаймні гарантує незначний хм.
Щоб допомогти з цими питаннями, метод Python sort () дозволяє включити вираз key = у круглі дужки, де ви можете сказати, як сортувати. Синтаксис:
.sort (ключ = перетворення)
Частина перетворення - це деяка зміна впорядкованих даних. Якщо вам пощастить, і одна з вбудованих функцій на кшталт len (для довжини) буде працювати для вас, то ви можете просто використовувати це замість трансформації, наприклад:
names.sort (key = len)
На жаль, для нас довжина рядка не допомагає з алфавіту. Отже, коли ви запускаєте це, замовлення виявляється таким:
['Ma', 'Adams', 'diMeola', 'Zandusky']
Сортування переходить від найкоротшої струни (тієї, яка має найменше символів), до найдовшої. Наразі не корисно.
Ви не можете писати key = нижній або key = верхній, щоб базувати сортування на всіх малих або великих літерах, тому що нижній і верхній букви не є вбудованими функціями (що ви можете швидко перевірити, вбудувавши в Google googling python 3.7 функції).
Замість вбудованої функції ви можете використовувати користувацьку функцію, яку ви самі визначаєте, використовуючи def. Наприклад, ви можете створити функцію з назвою нижня (), яка приймає рядок і повертає її з усіма її літерами, перетвореними в малі регістри. Ось функція:
def нижня (будь-яка нитка):
"" "Перетворює рядок у всі малі регістри" ""
повернути anystring.lower ()
Ім'я нижнього складається, і anystring є заповнювачем для будь-якого рядка, який ви перейдете до нього в майбутньому. Return anystring.lower () повертає ту рядку, перетворену на всі малі регістри, використовуючи метод .lower () об'єкта str (string). (Докладнішу інформацію читайте про нитки методів Python.)
Не можна використовувати ключі = = менші в дужках sort (), тому що нижня () не є вбудованою функцією. Це метод ... не той самий. Ніби неприємний з усіма цими казковими словами.
Припустимо, ви записуєте цю функцію у клітинку Jupyter або файл .py. Потім ви викликаєте функцію чимось на зразок друку (нижній регістр ('Зандуський')). Що ви отримуєте як вихід, - це рядок, перетворений у всі малі регістри.
Гаразд, тепер у вас є спеціальна функція для перетворення будь-якого рядка на всі малі літери. Як ви використовуєте це як ключ сортування? Легко, використовуйте ключ = перетворіть те саме, що і раніше, але замініть перетворення на власну назву функції Функція називається нижній регістр, тому ви використовуєте .sort (key = нижній регістр), як показано в наступному:
Def нижній регістр (anystring):
"" "Перетворює рядок у всі малі регістри" ""
повернути anystring.lower ()
 
names = ['Adams', 'Ma', 'diMeola', 'Zandusky']
names.sort (ключ = малий регістр)
Запуск цього коду для відображення списку імен приводить їх у правильний порядок, оскільки він ґрунтується на сортуванні на рядках, які є малі. Вихід такий самий, як і раніше, тому що лише для сортування, що проходив за кадром, використовували малі літери. Оригінальні дані зберігаються у великих і малих літерах.
'Адамс', 'diMeola', 'Ma', 'Zandusky'
Якщо ви все ще прокинулися і свідомі, прочитавши все це, ви можете задуматися: «Гаразд, ви вирішили проблему сортування. Але я подумав, що ми говоримо про функції лямбда. Де функція лямбда? »Ще немає функції лямбда.
Але це прекрасний приклад того, як ви можете використовувати лямбда-функцію, оскільки функція Python, яку ви викликаєте, нижній регістр (), виконує всю свою роботу лише одним рядком коду: return anystring.lower ().
Коли ваша функція може зробити це за допомогою простого однорядкового виразу на зразок цього, ви можете пропустити def і ім'я функції та просто використовувати цей синтаксис:
параметри лямбда: вираз
Замініть параметри одним або декількома іменами параметрів, які ви складаєте самостійно (імена всередині дужок після def та ім'я функції у звичайній функції). Замініть вираз тим, що ви хочете, щоб функція поверталася без слова return. Отже, у цьому прикладі ключовим, що використовує лямбда-вираз, буде:
лямбда будь-яка струна: anystring.lower ()
Тепер ви можете зрозуміти, чому це анонімна функція. Весь перший рядок з назвою функції нижнього регістру () видалено. Таким чином, перевага використання лямбда-виразу полягає в тому, що зовнішня спеціальна функція вам навіть не потрібна. Вам просто потрібен параметр, за яким слідує двокрапка і вираз, який підказує, що потрібно повернути.
На зображенні нижче показаний повний код та результат його запуску. Ви отримуєте належний порядок сортування без необхідності зовнішньої функції замовника, як нижній регістр (). Ви просто використовуєте anystring: anystring.lower () (після слова лямбда) як ключ сортування.
Додамо також, що anystring - це довше ім'я параметра, ніж більшість Pythonistas. Люди пітона люблять короткі імена, навіть однолітерні імена. Наприклад, ви можете замінити будь-яку нитку на s (або будь-яку іншу букву), як у наступному, і код буде працювати точно так само:
names = ['Adams', 'Ma', 'diMeola', 'Zandusky']
names.sort (ключ = лямбда s: s.lower ())
друк (імена)
Ще на початку цієї тиради було зазначено, що лямбда-функція не повинна бути анонімною. Ви можете давати їм імена та називати їх, як і інші функції.
Наприклад, ось функція лямбда з назвою валюта, яка приймає будь-яке число і повертає рядок у форматі валюти (тобто зі знаком провідного долара, комами між тисячами та двома цифрами за копійки):
валюта = лямбда n: f "$ {n:,. 2f}"
Ось один названий відсоток, який перемножує будь-яке число, яке ви йому надіслали, на 100 і показує його зі знаком двох відсотків у кінці:
відсотків = лямбда n: f "{n: .2%}"
На наступному зображенні показані приклади обох функцій, визначених у верхній частині комірки Юпітера. Потім кілька виписок друку викликають функції по імені та передають їм деякі зразкові дані. Кожен оператор print () відображає номер у бажаному форматі.
Причина, по якій ви можете визначити їх як однорядкові лямбдахи, полягає в тому, що ви можете виконати всю роботу в одному рядку, f "$ {n:,. 2f}" для першого і f "{n: .2%}" для другий. Але те, що ти можеш це зробити так, не означає, що ти повинен. Ви також можете використовувати звичайні функції:
# Показати номер у валютному форматі.
деф валюта (n):
return f "$ {n:,. 2f}"
 
def відсотків (n):
# Показати число у форматі відсотків.
повернути f "{n: .2%}"
З цим довшим синтаксисом ви можете також передавати більше інформації. Наприклад, ви можете встановити за замовчуванням формат, що вирівнюється вправо в межах певної ширини (скажімо, 15 символів), щоб усі цифри вийшли врівень праворуч на однакову ширину. Зображення показує цей варіант на двох функціях.
Використовуваний вище .ljust () - це вбудований рядовий метод Python, який прошиває ліву частину рядка з достатньою кількістю пробілів, щоб зробити задану ширину. Існує також метод rjust () для накладки правого боку. Ви також можете вказати символ, який не є пробілом. Google python 3 ljust rjust, якщо вам потрібна додаткова інформація.
Отже, у вас є це можливість створити власні власні функції в Python. У реальному житті те, що ти хочеш зробити, це щоразу, коли виявляєш, що тобі потрібен доступ до того ж фрагмента коду - того самого біта входу - знову і знову у вашому додатку, не просто копіюйте та не вставляйте цей фрагмент код знову і знову. Замість цього введіть увесь цей код у функцію, яку ви можете зателефонувати по імені.
Таким чином, якщо ви вирішили змінити рядок коду Python, вам не доведеться копати додаток, щоб знайти всі місця, які потребують змін. Просто змініть його у функції, де все визначено в одному місці.

